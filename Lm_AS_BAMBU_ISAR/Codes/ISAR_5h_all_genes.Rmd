---
title: "Bambu_0h-5h"
author: "Morgane Corre"
date: "`r Sys.Date()`"
output: html_document
---
LoVo cells were infected by Lm LL195 and total RNA has been extracted at several timepoints post infection (0h, 2h, 5h, 10h). RNAs have been sequenced using the Oxford Nanopore technology as long reads and have been mapped with Minimap2 in Galaxy on Gencode grch38 assembly. Thanks to Volker Böhm, from Köln University (Gehring lab), I've been able to extract which transcript isoforms were undergoing a change in expression, overall affecting the ratio of expressed isoforms for a given gene. As DEXSeq, usually recommended for this type of analysis, only works using reads aligned with RNA Star and that RNA Star is not suitable for mapping long reads yet, I used a conjunction of Bambu and IsoformSwitchAnalyzeR packages. Bambu is a R package for multi-sample transcript discovery and quantification using long read RNA-Seq data. IsoformSwitchAnalyzeR is for the analysis of alternative splicing and isoform switches with predicted functional consequences (e.g. gain/loss of protein domains etc.) from quantification of all types of RNASeq. In this case, I work directly on Bambu outputs but it can be directly plugged by pseudocounts reads generated by softwares like Salmon or Kallisto...

This analysis focuses on identifying the isoform switches between 0h and 5hPI.

Here is some documentation : 
[link](https://github.com/GoekeLab/bambu)
[link](http://bioconductor.org/packages/devel/bioc/vignettes/bambu/inst/doc/bambu.html)
[link](https://bioconductor.org/packages/release/bioc/manuals/IsoformSwitchAnalyzeR/man/IsoformSwitchAnalyzeR.pdf)

**BE MINDFUL** : Use the same Genome assembly in the code as the one used for the alignment and it's best to use the annotation file from the same server (Here Gencode). Also, when aligning, **make sure to set the --splice junction on TRUE**.

# SetUp

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(bambu))
suppressMessages(library(circlize))
suppressMessages(library(ComplexHeatmap))
suppressMessages(library(IsoformSwitchAnalyzeR))

```

Prepare a directory with the .bam files, the annotation file, the genome assembly file and a "design" table attibuting each sample to a condition.

```{r wd, echo = FALSE}
#use path to BAM files and/or reference files 
mydir="D:/Bioinformatics/Bambu_Nano/Bambu_Gencode_2"

#Load bam by recovering their names with the help of the sample table
samples <- read.table(file.path(mydir,"Samples_0h_5h.txt"), header = TRUE)
files <- file.path(mydir,"0h_5h",paste0(samples$Sample,".bam"))
names(files) <- samples$Sample
all(file.exists(files))

#Import genome, here, downloaded from gencode
fa.file <- file.path(mydir,"GRCh38.primary_assembly.genome.fa")
all(file.exists(fa.file))

#Import annotation file from the same database as genome
gtf.file <- file.path(mydir,"gencode.v36.annotation.gtf")
all(file.exists(gtf.file))

```
# Bambu

Create a bambu object, which is some kind of file flattening and Isoform discovery similar to DEXSeq but adapted to Nanopore reads

```{r bambuse, echo=FALSE}

# Flatten annotation file
bambuAnnotations <- prepareAnnotations(gtf.file)

#Generate Bambu object
se <- bambu(reads = files, rcOutDir = file.path(mydir, "bambu_file_0h_5h"), annotations = bambuAnnotations, genome = fa.file, stranded = FALSE, verbose = TRUE, discovery = FALSE)

```

Check samples homogeneity

```{r quality_plots, echo=FALSE}

colData(se)$condition <- as.factor(samples$Condition)

#plotBambu(se, type = "annotation", gene_id)

#plotBambu(se, type = "annotation", transcript_id)

plotBambu(se, type = "heatmap") # correlation heatmap

plotBambu(se, type = "pca") # PCA visualization

writeBambuOutput(se, path = file.path(mydir, "bambu_file_0h_5h_all"))

```

# ISAR

## Design and import data

Discovering isoform switches and their consequences on gene expression, using a DEXSeq like function. First create ISAR object.

```{r ISAR, echo=FALSE}

ref_dir="D:/Bioinformatics/Bambu_Nano/Bambu_Gencode_2"

#Contruct the design df from our sample table
myDesign <- data.frame(
  sampleID = samples$Sample,
  condition = samples$Condition
)

# condition string is the second, gets converted to character, change according to conditions
cond=c("0h","5h")
cond <- unlist(strsplit(cond,","))

# Get comparison data frame
myComparison <- data.frame(
  condition_1 = "0h",
  condition_2 = cond[-1]
)

# Generate SwitchList
SwitchList <- importRdata(
  isoformCountMatrix   = assays(se)$counts,
  isoformRepExpression = assays(se)$cpm,
  designMatrix         = myDesign,
  addAnnotatedORFs     = TRUE,
  onlyConsiderFullORF = FALSE,
  removeNonConvensionalChr = TRUE,
  isoformExonAnnoation = file.path(ref_dir, "gencode.v36.annotation.gtf"),
  comparisonsToMake= myComparison,        
  showProgress = TRUE,
  ignoreAfterBar = TRUE,
  ignoreAfterSpace = TRUE,
  ignoreAfterPeriod = FALSE,    # Set to FALSE for Gencode
  removeTECgenes = TRUE        # If set to TRUE, spike_ins need "gene_name" and "gene_type"
)

# What is in the Switchlist
SwitchList

```

## Filtering

Important : to get only significantly switching data, the **alpha** threshold must obvsiouly set at **0.05** and the **IFcutoff**, which represents the changes in (absolute) isoform usage before an isoform is considered eligible for switch testing, is at **0.1** (10%). As I wanted to basically extract all genes with switching isoforms, regardless of the significance, mostly to check CLK1's behavior, I set the **alpha** thresholf at 1 and the IFcutoff at 0.01. This is mostly due to the low coverage of MinION not being suitable for precise quantitative analyses.r.

```{r filter1, echo=FALSE}

# Filtering isoforms, the # arguments are the ones used for the primary generation of the switch table, whereas I look at the overall isoswitch on the 14/09/2022
SwitchList_filt <- preFilter(
  SwitchList,
  geneExpressionCutoff = 0.1, # FPMK threshold
  isoformExpressionCutoff = 0, # FPMK threshold
  #IFcutoff=0.01,
  IFcutoff=0,
  removeSingleIsoformGenes = TRUE,
  reduceToSwitchingGenes=FALSE,
  #alpha=0.05,
  alpha=1,
  dIFcutoff = 0.1,
  quiet=FALSE
)

```
## DEXSeq

```{r DEXseq, echo=FALSE}
# Testing for Isoform Switches via DEXSeq
SwitchList_filt_Analyzed <- isoformSwitchTestDEXSeq(
  switchAnalyzeRlist = SwitchList_filt,
  alpha = 1,
dIFcutoff = 0,
  reduceToSwitchingGenes=TRUE #keeps only genes with switching isoforms according to the given alpha and dIF
)

```



```{r more_folders, echo=FALSE}


# Create result folder if it does not exists, set to corresponding conditions
dir.create(file.path(mydir, "ISAR_0h_5h_all"), showWarnings = FALSE)

# Set new wd
setwd((file.path(mydir, "ISAR_0h_5h_all")))

save.image(file='ISAR_session.RData')

write.csv(SwitchList_filt$isoformFeatures, file="SwitchList_filt_0h_5h_all.csv")
write.csv(SwitchList_filt_Analyzed$isoformFeatures, file="SwitchList_filt_Analyzed_0h_5h_all.csv")

```

Regarding the switch csq analysis, argument : consequencestoAnalyze, one can either chose a specific consequences to display (NMD status).

## NMD Consquences 

```{r summarize, echo=FALSE}
# Summarize switching features
extractSwitchSummary(SwitchList_filt_Analyzed)

# Predicting Switch Consequences
SwitchList_filt_Analyzed <- analyzeSwitchConsequences(
  SwitchList_filt_Analyzed,
  consequencesToAnalyze = c('NMD_status'),
  dIFcutoff = 0,
  showProgress=TRUE
)

# Summarize switching features without consequences
extractSwitchSummary(SwitchList_filt_Analyzed, dIFcutoff = 0, filterForConsequences = FALSE)

# Summarize switching features with consequences
extractSwitchSummary(SwitchList_filt_Analyzed, dIFcutoff = 0, filterForConsequences = TRUE)

```
## TOP switches and switches of interest

### Plot top 20 switch plots

```{r analyze_top_switches, echo=FALSE}

#Plot Top 20 Switches, change file path to corresponding condition file
switchPlotTopSwitches(
  switchAnalyzeRlist = SwitchList_filt_Analyzed,
  n = 20,
  pathToOutput = file.path(mydir, "ISAR_0h_5h","Plots"),
  filterForConsequences = FALSE,
  splitFunctionalConsequences = TRUE
)

# Summarize switching features with consequences
extractTopSwitches(
  SwitchList_filt_Analyzed,
  filterForConsequences = TRUE,
  n = 20,
  sortByQvals = TRUE
)

```
### Volcano plot

```{r volcano, echo=FALSE}

# Volcano plot
pdf("Volcano_plot.pdf")
ggplot(data=SwitchList_filt_Analyzed$isoformFeatures, aes(x=dIF, y=-log10(isoform_switch_q_value))) +
  geom_point(
    aes( color=abs(dIF) > 0.1 & isoform_switch_q_value < 0.05 ), # default cutoff
    size=0.5
  ) +
  geom_hline(yintercept = -log10(0.05), linetype='dashed') + # default cutoff
  geom_vline(xintercept = c(-0.1, 0.1), linetype='dashed') + # default cutoff
  facet_wrap( ~ condition_2) +
  #facet_grid(condition_1 ~ condition_2) + # alternative to facet_wrap if you have overlapping conditions
  scale_color_manual('Signficant\nIsoform Switch', values = c('gray','red')) +
  labs(x='dIF', y='-Log10 ( Isoform Switch Q Value )') +
  theme_bw()
dev.off()

```
### CIRBP and CLK1

```{r switch_plots, echo=FALSE}


cirbp = switchPlot(
  SwitchList_filt_Analyzed,
  gene='CIRBP',
  condition1 = '0h',
  condition2 = '5h',
  localTheme = theme_bw(base_size = 10)
)

```

# Quit and Save

```{r save}
#change switchlist name and âth according to conditions
write.csv(SwitchList_filt_Analyzed$isoformFeatures, file="SwitchList_filt_Analyzed_0h_5h.csv")
save.image(file='ISAR_session.RData')

writeLines(capture.output(sessionInfo()), paste0(mydir, "/ISAR_0h_5h/ISAR_session_info.", format(Sys.time(), "%Y%m%d.%H%M"), ".txt"))

```

# Appendix

```{r, ref.label=knitr::all_labels(),echo=TRUE,eval=FALSE}
```
# End

```{r session_info}
sessionInfo()

```


